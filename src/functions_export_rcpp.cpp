#include "functions_export_rcpp.h"



Rcpp::List fetch_molec_data_list_from_bams_cpp(const Rcpp::CharacterVector& whichContext,
                                               const Rcpp::CharacterVector& infiles,
                                               const Rcpp::CharacterVector& regionChr,
                                               const Rcpp::IntegerVector& regionStart,
                                               const Rcpp::IntegerVector& regionEnd,
                                               const Rcpp::CharacterVector& seqstring,
                                               const Rcpp::IntegerVector& seqStart,
                                               const Rcpp::IntegerVector& seqEnd,
                                               const Rcpp::LogicalVector& remove_nonunique,
                                               const Rcpp::IntegerVector& clip_until_nbg,
                                               const Rcpp::NumericVector& max_protect_frac,
                                               const Rcpp::NumericVector& max_bisC_meth,
                                               const Rcpp::IntegerVector& min_bisC_size,
                                               const Rcpp::IntegerVector& mapqMin,
                                               const Rcpp::IntegerVector& mapqMax,
                                               const Rcpp::CharacterVector& alignerUsed,
                                               const Rcpp::CharacterVector& SMFenzymeUsed,
                                               const Rcpp::IntegerVector& min_frag_data_len,
                                               const Rcpp::NumericVector& min_frag_data_dens,
                                               const Rcpp::LogicalVector& data_as_rle){
  
  // convert input parameters
  string whichContext_ = Rcpp::as<string>(whichContext);
  fragMapType whichMap;
  if(whichContext_ == "GCH")
    whichMap = GCH;
  else if(whichContext_ == "WCG")
    whichMap = WCG;
  else if(whichContext_ == "bisC")
    whichMap = bisC;
  else if(whichContext_ == "otherC")
    whichMap = otherC;
  else if(whichContext_ == "allC")
    whichMap = allC;
  else
    Rcpp::stop("whichContext must be GCH, WCG, bisC, otherC or allC");
  
  string alignerUsed_ = Rcpp::as<string>(alignerUsed);
  alignerType aligner;
  if(alignerUsed_ == "QuasR")
    aligner = QuasR;
  else if(alignerUsed_ == "Bismark")
    aligner = Bismark;
  else if(alignerUsed_ == "BISCUIT")
    aligner = BISCUIT;
  else
    Rcpp::stop("Only alignments generated by QuasR, Bismark or BISCUIT can be analyzed\n");
  
  string SMFenzymeUsed_ = Rcpp::as<string>(SMFenzymeUsed);
  smf_enzyme SMFenzyme;
  if(SMFenzymeUsed_ == "M.CviPI")
    SMFenzyme = MCviPI;
  else if(SMFenzymeUsed_ == "DddB")
    SMFenzyme = DddB;
  else
    Rcpp::stop("Currently analysis of the data generated only with M.CviPI or DddB is supported\n");
  
  vector<string > infiles_ = Rcpp::as<vector<string > >(infiles);
  string regionChr_ = Rcpp::as<string >(regionChr);
  int regionStart_ = Rcpp::as<int >(regionStart);
  int regionEnd_ = Rcpp::as<int >(regionEnd);
  string seqstring_ = Rcpp::as<string >(seqstring);
  int seqStart_ = Rcpp::as<int >(seqStart);
  int seqEnd_ = Rcpp::as<int >(seqEnd);
  
  bool remove_nonunique_ = Rcpp::as<bool >(remove_nonunique);
  int clip_until_nbg_ = Rcpp::as<int >(clip_until_nbg);
  double max_protect_frac_ = Rcpp::as<double >(max_protect_frac);
  double max_bisC_meth_ = Rcpp::as<double >(max_bisC_meth);
  int min_bisC_size_ = Rcpp::as<int >(min_bisC_size);
  int mapqMin_ = Rcpp::as<int >(mapqMin);
  int mapqMax_ = Rcpp::as<int >(mapqMax);
  
  int min_frag_data_len_ = Rcpp::as<int >(min_frag_data_len);
  double min_frag_data_dens_ = Rcpp::as<double >(min_frag_data_dens);
  
  bool data_as_rle_ = Rcpp::as<bool >(data_as_rle);
  
  // initialize container for reference sequence
  refSeqInfo refseqInfo(seqstring_, seqStart_,seqEnd_);
  
  // initialize data structure for keeping object pointers
  obj_pnts pnts;
  // store pointer to reference sequence container
  pnts.refseq_info = &refseqInfo;
  // store min and amp MAPQ
  pnts.mapqMin = mapqMin_;
  pnts.mapqMax = mapqMax_;
  // store which enzyme was used
  pnts.SMFenzyme = SMFenzyme;
  
  
  // store which contexts to parse
  vector<fragMapType > cont_vec;
  // deaminase convert C->U which is read as T. Therefore all contexts must be considered and we set whichMap to allC
  if(SMFenzyme == DddB)
    whichMap = allC;
  
  if(whichMap == bisC){
    cont_vec = {bisC};
  } else if(whichMap == allC){
    cont_vec = {GCH, WCG, bisC, otherC};
  } else {
    if(max_bisC_meth_ < 1.0) // if filtering bisulfite failed reads needed we add bisC context
      cont_vec = {whichMap, bisC};
    else
      cont_vec = {whichMap};
  }
  pnts.context_vec = &cont_vec;
  
  // create container for fragments and counters
  regionData regData(regionChr_,regionStart_,regionEnd_);
  pnts.reg_data = &regData;
  
  int n_fetched = 0, n_nonUnique = 0, n_bisfailed = 0, n_analysed = 0, n_clipped = 0;
  
  // fetch data from all bam files
  for(int i = 0; i < infiles_.size(); ++i){
    pnts.prefix = "f" + to_string(i + 1)+":";
    // fetch data from bam file
    fetch_data_from_bam(infiles_[i],
                        regionChr_,
                        regionStart_,
                        regionEnd_,
                        aligner,
                        &pnts);
  }
  
  n_fetched = regData.size();

  // post-processing of the data, i.e. filtering by uniqueness, bisulfite efficiency, clipping and removal of fragments with insufficient data
  // function below returns the following stats
  // {n_nonUnique,n_bisfailed,n_clipped,n_insuffFailed,n_analysed}
  vector<int > filt_stats = regData.postProcessFragData(remove_nonunique_, 
                                                        clip_until_nbg_, 
                                                        max_protect_frac_, 
                                                        max_bisC_meth_,
                                                        min_bisC_size_,
                                                        min_frag_data_len_,
                                                        min_frag_data_dens_,
                                                        whichMap);
  
  
  // create List with fetched reads/fragments for R with the following information
  // start (genomic position of the first data point. note, not the alignment start!)
  // end last position of the data points
  // R1strand strand where the R1 read aligned
  // qname - name of the fragment
  // GCH_fragData_list list which contains vectors with 0 (accessible), 1(protected) and NA, non-informative
  Rcpp::List data_out;
  if(data_as_rle_)
    data_out = regData.getFragDataRle(whichMap);
  else
    data_out = regData.getFragDataList(whichMap);
  return(data_out);
}




Rcpp::List fetch_cooc_ctable_from_bams_cpp(const Rcpp::CharacterVector& infiles,
                                           const Rcpp::CharacterVector& regionChr,
                                           const Rcpp::IntegerVector& regionStart,
                                           const Rcpp::IntegerVector& regionEnd,
                                           const Rcpp::IntegerVector& max_spac,
                                           const Rcpp::CharacterVector& seqstring,
                                           const Rcpp::IntegerVector& seqStart,
                                           const Rcpp::IntegerVector& seqEnd,
                                           const Rcpp::LogicalVector& remove_nonunique,
                                           const Rcpp::IntegerVector& clip_until_nbg,
                                           const Rcpp::NumericVector& max_protect_frac,
                                           const Rcpp::NumericVector& max_bisC_meth,
                                           const Rcpp::IntegerVector& min_bisC_size,
                                           const Rcpp::IntegerVector& mapqMin,
                                           const Rcpp::IntegerVector& mapqMax,
                                           const Rcpp::CharacterVector& alignerUsed,
                                           const Rcpp::CharacterVector& SMFenzymeUsed,
                                           const Rcpp::IntegerVector& min_frag_data_len,
                                           const Rcpp::NumericVector& min_frag_data_dens){
  
  string alignerUsed_ = Rcpp::as<string>(alignerUsed);
  alignerType aligner;
  if(alignerUsed_ == "QuasR")
    aligner = QuasR;
  else if(alignerUsed_ == "Bismark")
    aligner = Bismark;
  else if(alignerUsed_ == "BISCUIT")
    aligner = BISCUIT;
  else
    Rcpp::stop("Only alignments generated by QuasR, Bismark or BISCUIT can be analyzed\n");
  
  string SMFenzymeUsed_ = Rcpp::as<string>(SMFenzymeUsed);
  smf_enzyme SMFenzyme;
  
  if(SMFenzymeUsed_ == "M.CviPI")
    SMFenzyme = MCviPI;
  else if(SMFenzymeUsed_ == "DddB")
    SMFenzyme = DddB;
  else
    Rcpp::stop("Currently analysis of the data generated only with M.CviPI or DddB is supported\n");
  
  // convert input parameters
  vector<string > infiles_ = Rcpp::as<vector<string > >(infiles);
  string regionChr_ = Rcpp::as<string >(regionChr);
  int regionStart_ = Rcpp::as<int >(regionStart);
  int regionEnd_ = Rcpp::as<int >(regionEnd);
  int max_spac_ = Rcpp::as<int >(max_spac);
  string seqstring_ = Rcpp::as<string >(seqstring);
  int seqStart_ = Rcpp::as<int >(seqStart);
  int seqEnd_ = Rcpp::as<int >(seqEnd);
  
  bool remove_nonunique_ = Rcpp::as<bool >(remove_nonunique);
  int clip_until_nbg_ = Rcpp::as<int >(clip_until_nbg);
  double max_protect_frac_ = Rcpp::as<double >(max_protect_frac);
  double max_bisC_meth_ = Rcpp::as<double >(max_bisC_meth);
  int min_bisC_size_ = Rcpp::as<int >(min_bisC_size);
  int mapqMin_ = Rcpp::as<int >(mapqMin);
  int mapqMax_ = Rcpp::as<int >(mapqMax);
  
  int min_frag_data_len_ = Rcpp::as<int >(min_frag_data_len);
  double min_frag_data_dens_ = Rcpp::as<double >(min_frag_data_dens);
  
  // initialize container for reference sequence
  refSeqInfo refseqInfo(seqstring_, seqStart_,seqEnd_);
  
  // initialize data structure for keeping object pointers
  obj_pnts pnts;
  // store pointer to reference sequence container
  pnts.refseq_info = &refseqInfo;
  // store min and max MAPQ
  pnts.mapqMin = mapqMin_;
  pnts.mapqMax = mapqMax_;
  // store which enzyme was used
  pnts.SMFenzyme = SMFenzyme;
  
  // store which contexts to parse
  vector<fragMapType > cont_vec;
  switch(SMFenzyme) {
  case MCviPI:{
    if(max_bisC_meth_ < 1.0) // if filtering bisulfite failed reads needed we add bisC context
      cont_vec = {GCH, bisC};
    else
      cont_vec = {GCH};
    break;
  }
  case DddB:{
    cont_vec = {GCH, WCG, bisC, otherC}; // deaminase convert C->U which is read as T. Therefore all contexts must be considered
    break;
  }
  default:
    Rcpp::stop("Currently analysis of the data generated only with M.CviPI or DddB is supported\n");
  }
  pnts.context_vec = &cont_vec;
  
  // initialize container for cooccurrence counts and counters
  coocCntTable cTable(max_spac_);
  int n_fetched = 0, n_nonUnique = 0, n_bisfailed = 0, n_analysed = 0, n_clipped = 0;
  
  // for each bam file fetch data and add counts to cooccurrence table 
  for(int i = 0; i < infiles_.size(); ++i){
    // initialize container for fragments in region
    regionData regData(regionChr_,regionStart_,regionEnd_);
    pnts.reg_data = &regData;
    pnts.prefix = "f" + to_string(i + 1)+":";
    // fetch data from bam file
    fetch_data_from_bam(infiles_[i],
                        regionChr_,
                        regionStart_,
                        regionEnd_,
                        aligner,
                        &pnts);
    n_fetched += regData.size();
    
    
    // post-processing of the data, i.e. filtering by uniqueness, bisulfite efficiency, clipping and removal of fragments with insufficient data
    // function below returns the following stats
    // {n_nonUnique,n_bisfailed,n_clipped,n_insuffFailed,n_analysed}
    // here we don't depend on the enzyme as deaminase data all stored in gchProtect map
    vector<int > filt_stats = regData.postProcessFragData(remove_nonunique_,
                                                          clip_until_nbg_, 
                                                          max_protect_frac_, 
                                                          max_bisC_meth_,
                                                          min_bisC_size_,
                                                          min_frag_data_len_,
                                                          min_frag_data_dens_,
                                                          GCH);
    n_nonUnique += filt_stats[0];
    n_bisfailed += filt_stats[1];
    n_clipped += filt_stats[2];
    n_analysed += filt_stats[4];
    
    // add counts to table
    regData.addCountsToCoocTable(cTable);
  }
  
  // convert count table to R matrix and return
  Rcpp::IntegerMatrix cntbl(max_spac_,4);
  vector<string > rownm;
  for(int row = 0; row < max_spac_; ++row){
    for(int col = 0; col < 4; ++col)
      cntbl(row, col) = cTable.get_element(row, col);
    rownm.push_back(to_string(row+1));
    
  }
  Rcpp::CharacterVector colnm = {"N00","N01","N10","N11"};
  
  Rcpp::colnames(cntbl) = colnm;
  Rcpp::rownames(cntbl) = Rcpp::wrap(rownm);
  // create List for R
  Rcpp::List data_out = Rcpp::List::create(Rcpp::Named("nFragsFetched") = Rcpp::wrap(n_fetched),
                                           Rcpp::Named("nFragsNonUnique") = Rcpp::wrap(n_nonUnique),
                                           Rcpp::Named("nFragsBisFailed") = Rcpp::wrap(n_bisfailed),
                                           Rcpp::Named("nFragsAnalyzed") = Rcpp::wrap(n_analysed),
                                           Rcpp::Named("ClippedUntilNbg") = Rcpp::wrap(clip_until_nbg_),
                                           Rcpp::Named("NotClippedProtectAbove") = Rcpp::wrap(max_protect_frac_),
                                           Rcpp::Named("nFragsClipped") = Rcpp::wrap(n_clipped),
                                           Rcpp::Named("CoocCountTable") = cntbl);
  return(data_out);
}



Rcpp::List fetch_data_matrix_from_bams_cpp(const Rcpp::CharacterVector& whichContext,
                                           const Rcpp::CharacterVector& infiles,
                                           const Rcpp::CharacterVector& regionChr,
                                           const Rcpp::IntegerVector& regionStart,
                                           const Rcpp::IntegerVector& regionEnd,
                                           const Rcpp::CharacterVector& seqstring,
                                           const Rcpp::IntegerVector& seqStart,
                                           const Rcpp::IntegerVector& seqEnd,
                                           const Rcpp::LogicalVector& remove_nonunique,
                                           const Rcpp::IntegerVector& clip_until_nbg,
                                           const Rcpp::NumericVector& max_protect_frac,
                                           const Rcpp::NumericVector& max_bisC_meth,
                                           const Rcpp::IntegerVector& min_bisC_size,
                                           const Rcpp::IntegerVector& mapqMin,
                                           const Rcpp::IntegerVector& mapqMax,
                                           const Rcpp::CharacterVector& alignerUsed,
                                           const Rcpp::CharacterVector& SMFenzymeUsed,
                                           const Rcpp::IntegerVector& min_frag_data_len,
                                           const Rcpp::NumericVector& min_frag_data_dens){
  
  // convert input parameters
  string whichContext_ = Rcpp::as<string>(whichContext);
  fragMapType whichMap;
  if(whichContext_ == "GCH")
    whichMap = GCH;
  else if(whichContext_ == "WCG")
    whichMap = WCG;
  else if(whichContext_ == "bisC")
    whichMap = bisC;
  else if(whichContext_ == "otherC")
    whichMap = otherC;
  else if(whichContext_ == "allC")
    whichMap = allC;
  else
    Rcpp::stop("whichContext must be GCH, WCG, bisC, otherC or allC");
  
  string alignerUsed_ = Rcpp::as<string>(alignerUsed);
  alignerType aligner;
  if(alignerUsed_ == "QuasR")
    aligner = QuasR;
  else if(alignerUsed_ == "Bismark")
    aligner = Bismark;
  else if(alignerUsed_ == "BISCUIT")
    aligner = BISCUIT;
  else
    Rcpp::stop("Only alignments generated by QuasR, Bismark or BISCUIT can be analyzed\n");
  
  string SMFenzymeUsed_ = Rcpp::as<string>(SMFenzymeUsed);
  smf_enzyme SMFenzyme;
  if(SMFenzymeUsed_ == "M.CviPI")
    SMFenzyme = MCviPI;
  else if(SMFenzymeUsed_ == "DddB")
    SMFenzyme = DddB;
  else
    Rcpp::stop("Currently analysis of the data generated only with M.CviPI or DddB is supported\n");
  
  vector<string > infiles_ = Rcpp::as<vector<string > >(infiles);
  string regionChr_ = Rcpp::as<string >(regionChr);
  int regionStart_ = Rcpp::as<int >(regionStart);
  int regionEnd_ = Rcpp::as<int >(regionEnd);
  string seqstring_ = Rcpp::as<string >(seqstring);
  int seqStart_ = Rcpp::as<int >(seqStart);
  int seqEnd_ = Rcpp::as<int >(seqEnd);
  
  bool remove_nonunique_ = Rcpp::as<bool >(remove_nonunique);
  int clip_until_nbg_ = Rcpp::as<int >(clip_until_nbg);
  double max_protect_frac_ = Rcpp::as<double >(max_protect_frac);
  double max_bisC_meth_ = Rcpp::as<double >(max_bisC_meth);
  int min_bisC_size_ = Rcpp::as<int >(min_bisC_size);
  int mapqMin_ = Rcpp::as<int >(mapqMin);
  int mapqMax_ = Rcpp::as<int >(mapqMax);
  
  int min_frag_data_len_ = Rcpp::as<int >(min_frag_data_len);
  double min_frag_data_dens_ = Rcpp::as<double >(min_frag_data_dens);
  // initialize container for reference sequence
  refSeqInfo refseqInfo(seqstring_, seqStart_,seqEnd_);
  
  // initialize data structure for keeping object pointers
  obj_pnts pnts;
  // store pointer to reference sequence container
  pnts.refseq_info = &refseqInfo;
  // store min and amp MAPQ
  pnts.mapqMin = mapqMin_;
  pnts.mapqMax = mapqMax_;
  // store which enzyme was used
  pnts.SMFenzyme = SMFenzyme;
  
  // store which contexts to parse
  vector<fragMapType > cont_vec;
  // deaminase convert C->U which is read as T. Therefore all contexts must be considered and we set whichMap to allC
  if(SMFenzyme == DddB)
    whichMap = allC;
  
  if(whichMap == bisC){
    cont_vec = {bisC};
  } else if(whichMap == allC){
    cont_vec = {GCH, WCG, bisC, otherC};
  } else {
    if(max_bisC_meth_ < 1.0) // if filtering bisulfite failed reads needed we add bisC context
      cont_vec = {whichMap, bisC};
    else
      cont_vec = {whichMap};
  }
  pnts.context_vec = &cont_vec;
  
  // create container for fragments and counters
  regionData regData(regionChr_,regionStart_,regionEnd_);
  pnts.reg_data = &regData;
  int n_fetched = 0, n_nonUnique = 0, n_bisfailed = 0, n_analysed = 0, n_clipped = 0;
  
  // fetch data from all bam files
  for(int i = 0; i < infiles_.size(); ++i){
    pnts.prefix = "f" + to_string(i + 1)+":";
    // fetch data from bam file
    fetch_data_from_bam(infiles_[i],
                        regionChr_,
                        regionStart_,
                        regionEnd_,
                        aligner,
                        &pnts);
  }
  
  n_fetched = regData.size();
  
  // post-processing of the data, i.e. filtering by uniqueness, bisulfite efficiency, clipping and removal of fragments with insufficient data
  // function below returns the following stats
  // {n_nonUnique,n_bisfailed,n_clipped,n_insuffFailed,n_analysed}
  vector<int > filt_stats = regData.postProcessFragData(remove_nonunique_, 
                                                        clip_until_nbg_, 
                                                        max_protect_frac_, 
                                                        max_bisC_meth_,
                                                        min_bisC_size_,
                                                        min_frag_data_len_,
                                                        min_frag_data_dens_,
                                                        whichMap);
  n_nonUnique += filt_stats[0];
  n_bisfailed += filt_stats[1];
  n_clipped += filt_stats[2];
  n_analysed += filt_stats[4];
  
  
  // create List for R
  Rcpp::List data_out = Rcpp::List::create(Rcpp::Named("nFragsFetched") = Rcpp::wrap(n_fetched),
                                           Rcpp::Named("nFragsNonUnique") = Rcpp::wrap(n_nonUnique),
                                           Rcpp::Named("nFragsBisFailed") = Rcpp::wrap(n_bisfailed),
                                           Rcpp::Named("nFragsAnalyzed") = Rcpp::wrap(n_analysed),
                                           Rcpp::Named("ClippedUntilNbg") = Rcpp::wrap(clip_until_nbg_),
                                           Rcpp::Named("NotClippedProtectAbove") = Rcpp::wrap(max_protect_frac_),
                                           Rcpp::Named("nFragsClipped") = Rcpp::wrap(n_clipped),
                                           Rcpp::Named("DataMatrix") = regData.getDataMatrix(whichMap));
  return(data_out);
}



Rcpp::List fetch_protect_stats_from_bams_cpp(const Rcpp::CharacterVector& infiles,
                                             const Rcpp::CharacterVector& regionChr,
                                             const Rcpp::IntegerVector& regionStart,
                                             const Rcpp::IntegerVector& regionEnd,
                                             const Rcpp::CharacterVector& seqstring,
                                             const Rcpp::IntegerVector& seqStart,
                                             const Rcpp::IntegerVector& seqEnd,
                                             const Rcpp::LogicalVector& remove_nonunique,
                                             const Rcpp::IntegerVector& clip_until_nbg,
                                             const Rcpp::NumericVector& max_protect_frac,
                                             const Rcpp::NumericVector& max_bisC_meth,
                                             const Rcpp::IntegerVector& min_bisC_size,
                                             const Rcpp::IntegerVector& mapqMin,
                                             const Rcpp::IntegerVector& mapqMax,
                                             const Rcpp::CharacterVector& alignerUsed,
                                             const Rcpp::CharacterVector& SMFenzymeUsed,
                                             const Rcpp::IntegerVector& min_frag_data_len,
                                             const Rcpp::NumericVector& min_frag_data_dens){
  
  
  string alignerUsed_ = Rcpp::as<string>(alignerUsed);
  alignerType aligner;
  if(alignerUsed_ == "QuasR")
    aligner = QuasR;
  else if(alignerUsed_ == "Bismark")
    aligner = Bismark;
  else if(alignerUsed_ == "BISCUIT")
    aligner = BISCUIT;
  else
    Rcpp::stop("Only alignments generated by QuasR, Bismark or BISCUIT can be analyzed\n");
  
  string SMFenzymeUsed_ = Rcpp::as<string>(SMFenzymeUsed);
  smf_enzyme SMFenzyme;
  if(SMFenzymeUsed_ == "M.CviPI")
    SMFenzyme = MCviPI;
  else if(SMFenzymeUsed_ == "DddB")
    SMFenzyme = DddB;
  else
    Rcpp::stop("Currently analysis of the data generated only with M.CviPI or DddB is supported\n");
  
  // convert input parameters
  vector<string > infiles_ = Rcpp::as<vector<string > >(infiles);
  string regionChr_ = Rcpp::as<string >(regionChr);
  int regionStart_ = Rcpp::as<int >(regionStart);
  int regionEnd_ = Rcpp::as<int >(regionEnd);
  string seqstring_ = Rcpp::as<string >(seqstring);
  int seqStart_ = Rcpp::as<int >(seqStart);
  int seqEnd_ = Rcpp::as<int >(seqEnd);
  
  bool remove_nonunique_ = Rcpp::as<bool >(remove_nonunique);
  int clip_until_nbg_ = Rcpp::as<int >(clip_until_nbg);
  double max_protect_frac_ = Rcpp::as<double >(max_protect_frac);
  double max_bisC_meth_ = Rcpp::as<double >(max_bisC_meth);
  int min_bisC_size_ = Rcpp::as<int >(min_bisC_size);
  int mapqMin_ = Rcpp::as<int >(mapqMin);
  int mapqMax_ = Rcpp::as<int >(mapqMax);
  int min_frag_data_len_ = Rcpp::as<int >(min_frag_data_len);
  double min_frag_data_dens_ = Rcpp::as<double >(min_frag_data_dens);
  
  // initialize container for reference sequence
  refSeqInfo refseqInfo(seqstring_, seqStart_,seqEnd_);
  
  // initialize data structure for keeping object pointers
  obj_pnts pnts;
  // store pointer to reference sequence container
  pnts.refseq_info = &refseqInfo;
  // store min and max MAPQ
  pnts.mapqMin = mapqMin_;
  pnts.mapqMax = mapqMax_;
  // store which enzyme was used
  pnts.SMFenzyme = SMFenzyme;
  
  // store which contexts to parse
  vector<fragMapType > cont_vec;
  switch(SMFenzyme) {
  case MCviPI:{
    if(max_bisC_meth_ < 1.0) // if filtering bisulfite failed reads needed we add bisC context
      cont_vec = {GCH, bisC};
    else
      cont_vec = {GCH};
    break;
  }
  case DddB:{
    cont_vec = {GCH, WCG, bisC, otherC}; // deaminase convert C->U which is read as T. Therefore all contexts must be considered
    break;
  }
  default:
    Rcpp::stop("Currently analysis of the data generated only with M.CviPI or DddB is supported\n");
  }
  pnts.context_vec = &cont_vec;
  
  // initialize container for collecting protect statistics and counters
  protectStatsTable protStats;
  int n_fetched = 0, n_nonUnique = 0, n_bisfailed = 0, n_analysed = 0, n_clipped = 0;
  // for each bam file fetch data and add counts to protect stats table 
  for(int i = 0; i < infiles_.size(); ++i){
    // initialize container for fragments in region
    regionData regData(regionChr_,regionStart_,regionEnd_);
    pnts.reg_data = &regData;
    pnts.prefix = "f" + to_string(i + 1)+":";
    // fetch data from bam file
    fetch_data_from_bam(infiles_[i],
                        regionChr_,
                        regionStart_,
                        regionEnd_,
                        aligner,
                        &pnts);
    n_fetched += regData.size();
    
    // post-processing of the data, i.e. filtering by uniqueness, bisulfite efficiency, clipping and removal of fragments with insufficient data
    // function below returns the following stats
    // {n_nonUnique,n_bisfailed,n_clipped,n_insuffFailed,n_analysed}
    vector<int > filt_stats = regData.postProcessFragData(remove_nonunique_, 
                                                          clip_until_nbg_, 
                                                          max_protect_frac_, 
                                                          max_bisC_meth_,
                                                          min_bisC_size_,
                                                          min_frag_data_len_,
                                                          min_frag_data_dens_,
                                                          GCH);
    n_nonUnique += filt_stats[0];
    n_bisfailed += filt_stats[1];
    n_clipped += filt_stats[2];
    n_analysed += filt_stats[4];
    
    // add counts to protect stat table
    regData.addCountsToProtectStatsTable(protStats);
  }
  
  // convert stat table to R matrix
  vector<vector<int >> stTbl = protStats.getStatTable();
  
  Rcpp::IntegerMatrix pStatMatr(stTbl.size(),3);
  for(int i=0;i<stTbl.size(); ++i){
    pStatMatr(i,0) = stTbl[i][0];
    pStatMatr(i,1) = stTbl[i][1];
    pStatMatr(i,2) = stTbl[i][2];
  }
  
  Rcpp::CharacterVector colnm = {"TotalGCH","ProtectedGCH","Nfrags"};
  
  Rcpp::colnames(pStatMatr) = colnm;
  
  // create List for R
  Rcpp::List data_out = Rcpp::List::create(Rcpp::Named("nFragsFetched") = Rcpp::wrap(n_fetched),
                                           Rcpp::Named("nFragsNonUnique") = Rcpp::wrap(n_nonUnique),
                                           Rcpp::Named("nFragsBisFailed") = Rcpp::wrap(n_bisfailed),
                                           Rcpp::Named("nFragsAnalyzed") = Rcpp::wrap(n_analysed),
                                           Rcpp::Named("ClippedUntilNbg") = Rcpp::wrap(clip_until_nbg_),
                                           Rcpp::Named("NotClippedProtectAbove") = Rcpp::wrap(max_protect_frac_),
                                           Rcpp::Named("nFragsClipped") = Rcpp::wrap(n_clipped),
                                           Rcpp::Named("ProtectStats") = pStatMatr);
  return(data_out);
}



